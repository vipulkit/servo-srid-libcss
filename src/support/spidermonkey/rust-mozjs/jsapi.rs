/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */

/* automatically generated by rust-bindgen */

#[allow(non_uppercase_statics)];

use std::libc::*;
use jsfriendapi::JSJitInfo;

pub type moz_static_assert0 = c_int;

pub type moz_static_assert1 = c_int;

pub type moz_static_assert2 = c_int;

pub type moz_static_assert3 = c_int;

pub type moz_static_assert4 = c_int;

pub type union_MozDoublePun = c_void /* FIXME: union type */;

pub type JSBool = c_int;

pub type jsid = ptrdiff_t;

pub type jschar = uint16_t;

pub type enum_JSVersion = c_int;
pub static JSVERSION_1_0: i32 = 100_i32;
pub static JSVERSION_1_1: i32 = 110_i32;
pub static JSVERSION_1_2: i32 = 120_i32;
pub static JSVERSION_1_3: i32 = 130_i32;
pub static JSVERSION_1_4: i32 = 140_i32;
pub static JSVERSION_ECMA_3: i32 = 148_i32;
pub static JSVERSION_1_5: i32 = 150_i32;
pub static JSVERSION_1_6: i32 = 160_i32;
pub static JSVERSION_1_7: i32 = 170_i32;
pub static JSVERSION_1_8: i32 = 180_i32;
pub static JSVERSION_ECMA_5: i32 = 185_i32;
pub static JSVERSION_DEFAULT: i32 = 0_i32;
pub static JSVERSION_UNKNOWN: i32 = -1_i32;
pub static JSVERSION_LATEST: i32 = 185_i32;

pub type JSVersion = enum_JSVersion;

pub type enum_JSType = c_uint;
pub static JSTYPE_VOID: u32 = 0_u32;
pub static JSTYPE_OBJECT: u32 = 1_u32;
pub static JSTYPE_FUNCTION: u32 = 2_u32;
pub static JSTYPE_STRING: u32 = 3_u32;
pub static JSTYPE_NUMBER: u32 = 4_u32;
pub static JSTYPE_BOOLEAN: u32 = 5_u32;
pub static JSTYPE_NULL: u32 = 6_u32;
pub static JSTYPE_XML: u32 = 7_u32;
pub static JSTYPE_LIMIT: u32 = 8_u32;

pub type JSType = enum_JSType;

pub type enum_JSProtoKey = c_uint;
pub static JSProto_Null: u32 = 0_u32;
pub static JSProto_Object: u32 = 1_u32;
pub static JSProto_Function: u32 = 2_u32;
pub static JSProto_Array: u32 = 3_u32;
pub static JSProto_Boolean: u32 = 4_u32;
pub static JSProto_JSON: u32 = 5_u32;
pub static JSProto_Date: u32 = 6_u32;
pub static JSProto_Math: u32 = 7_u32;
pub static JSProto_Number: u32 = 8_u32;
pub static JSProto_String: u32 = 9_u32;
pub static JSProto_RegExp: u32 = 10_u32;
pub static JSProto_XML: u32 = 11_u32;
pub static JSProto_Namespace: u32 = 12_u32;
pub static JSProto_QName: u32 = 13_u32;
pub static JSProto_Error: u32 = 14_u32;
pub static JSProto_InternalError: u32 = 15_u32;
pub static JSProto_EvalError: u32 = 16_u32;
pub static JSProto_RangeError: u32 = 17_u32;
pub static JSProto_ReferenceError: u32 = 18_u32;
pub static JSProto_SyntaxError: u32 = 19_u32;
pub static JSProto_TypeError: u32 = 20_u32;
pub static JSProto_URIError: u32 = 21_u32;
pub static JSProto_Iterator: u32 = 22_u32;
pub static JSProto_StopIteration: u32 = 23_u32;
pub static JSProto_ArrayBuffer: u32 = 24_u32;
pub static JSProto_Int8Array: u32 = 25_u32;
pub static JSProto_Uint8Array: u32 = 26_u32;
pub static JSProto_Int16Array: u32 = 27_u32;
pub static JSProto_Uint16Array: u32 = 28_u32;
pub static JSProto_Int32Array: u32 = 29_u32;
pub static JSProto_Uint32Array: u32 = 30_u32;
pub static JSProto_Float32Array: u32 = 31_u32;
pub static JSProto_Float64Array: u32 = 32_u32;
pub static JSProto_Uint8ClampedArray: u32 = 33_u32;
pub static JSProto_Proxy: u32 = 34_u32;
pub static JSProto_AnyName: u32 = 35_u32;
pub static JSProto_WeakMap: u32 = 36_u32;
pub static JSProto_Map: u32 = 37_u32;
pub static JSProto_Set: u32 = 38_u32;
pub static JSProto_DataView: u32 = 39_u32;
pub static JSProto_ParallelArray: u32 = 40_u32;
pub static JSProto_LIMIT: u32 = 41_u32;

pub type JSProtoKey = enum_JSProtoKey;

pub type enum_JSAccessMode = c_uint;
pub static JSACC_PROTO: u32 = 0_u32;
pub static JSACC_WATCH: u32 = 3_u32;
pub static JSACC_READ: u32 = 4_u32;
pub static JSACC_WRITE: u32 = 8_u32;
pub static JSACC_LIMIT: u32 = 9_u32;

pub type JSAccessMode = enum_JSAccessMode;

pub type enum_JSIterateOp = c_uint;
pub static JSENUMERATE_INIT: u32 = 0_u32;
pub static JSENUMERATE_INIT_ALL: u32 = 1_u32;
pub static JSENUMERATE_NEXT: u32 = 2_u32;
pub static JSENUMERATE_DESTROY: u32 = 3_u32;

pub type JSIterateOp = enum_JSIterateOp;


pub type JSGCTraceKind = c_uint;
pub static JSTRACE_OBJECT: u32 = 0_u32;
pub static JSTRACE_STRING: u32 = 1_u32;
pub static JSTRACE_SCRIPT: u32 = 2_u32;
pub static JSTRACE_XML: u32 = 3_u32;
pub static JSTRACE_SHAPE: u32 = 4_u32;
pub static JSTRACE_BASE_SHAPE: u32 = 5_u32;
pub static JSTRACE_TYPE_OBJECT: u32 = 6_u32;
pub static JSTRACE_LAST: u32 = 6_u32;

pub type struct_JSCompartment = c_void;

pub type JSCompartment = struct_JSCompartment;

pub type JSConstDoubleSpec = struct_JSConstDoubleSpec;

pub type struct_JSContext = c_void;

pub type JSContext = struct_JSContext;

pub type struct_JSCrossCompartmentCall = c_void;

pub type JSCrossCompartmentCall = struct_JSCrossCompartmentCall;

pub type JSErrorReport = struct_JSErrorReport;

pub type struct_JSExceptionState = c_void;

pub type JSExceptionState = struct_JSExceptionState;

pub type struct_JSFunction = c_void;

pub type JSFunction = struct_JSFunction;

pub type struct_JSIdArray = c_void;

pub type JSIdArray = struct_JSIdArray;

pub type JSLocaleCallbacks = struct_JSLocaleCallbacks;

pub type struct_JSObject = c_void;

pub type JSObject = struct_JSObject;

pub type struct_JSObjectMap = c_void;

pub type JSObjectMap = struct_JSObjectMap;

pub type JSPrincipals = struct_JSPrincipals;

pub type JSPropertyDescriptor = struct_JSPropertyDescriptor;

pub type struct_JSPropertyName = c_void;

pub type JSPropertyName = struct_JSPropertyName;

pub type struct_JSRuntime = c_void;

pub type JSRuntime = struct_JSRuntime;

pub type JSSecurityCallbacks = struct_JSSecurityCallbacks;

pub type struct_JSStackFrame = c_void;

pub type JSStackFrame = struct_JSStackFrame;

pub type struct_JSScript = c_void;

pub type JSScript = struct_JSScript;

pub type JSStructuredCloneCallbacks = struct_JSStructuredCloneCallbacks;

pub type struct_JSStructuredCloneReader = c_void;

pub type JSStructuredCloneReader = struct_JSStructuredCloneReader;

pub type struct_JSStructuredCloneWriter = c_void;

pub type JSStructuredCloneWriter = struct_JSStructuredCloneWriter;

pub type JSTracer = struct_JSTracer;

pub type struct_JSFlatString = c_void;

pub type JSFlatString = struct_JSFlatString;

pub type struct_JSString = c_void;

pub type JSString = struct_JSString;

pub type JSCallOnceType = JSBool;

pub type JSInitCallback = *u8;

pub type JSMallocSizeOfFun = *u8;

pub type jsbitmap = size_t;

pub type JSValueType = uint8_t;

pub type JSValueTag = uint32_t;

pub type JSValueShiftedTag = uint64_t;

pub type enum_JSWhyMagic = c_uint;
pub static JS_ARRAY_HOLE: u32 = 0_u32;
pub static JS_NATIVE_ENUMERATE: u32 = 1_u32;
pub static JS_NO_ITER_VALUE: u32 = 2_u32;
pub static JS_GENERATOR_CLOSING: u32 = 3_u32;
pub static JS_NO_CONSTANT: u32 = 4_u32;
pub static JS_THIS_POISON: u32 = 5_u32;
pub static JS_ARG_POISON: u32 = 6_u32;
pub static JS_SERIALIZE_NO_NODE: u32 = 7_u32;
pub static JS_LAZY_ARGUMENTS: u32 = 8_u32;
pub static JS_OPTIMIZED_ARGUMENTS: u32 = 9_u32;
pub static JS_IS_CONSTRUCTING: u32 = 10_u32;
pub static JS_OVERWRITTEN_CALLEE: u32 = 11_u32;
pub static JS_FORWARD_TO_CALL_OBJECT: u32 = 12_u32;
pub static JS_BLOCK_NEEDS_CLONE: u32 = 13_u32;
pub static JS_HASH_KEY_EMPTY: u32 = 14_u32;
pub static JS_GENERIC_MAGIC: u32 = 15_u32;

pub type JSWhyMagic = enum_JSWhyMagic;

pub type union_jsval_layout = c_void /* FIXME: union type */;

pub type jsval_layout = union_jsval_layout;

pub type moz_static_assert5 = c_int;

pub type moz_static_assert6 = c_int;

// JSVal was originally type of u64. 
// now this become {u64} because of the union abi issue on ARM arch. See #398.
#[deriving(Eq)]
pub struct JSVal {
    v: u64
}

pub struct JSHandleObject {
    unnamed: **JSObject,
}

pub struct JSHandleValue {
    unnamed: JSVal,
}

pub struct JSHandleString {
    unnamed: **JSString,
}

pub struct JSMutableHandleObject {
    unnamed: **JSObject,
}

pub struct JSHandleId {
    unnamed: *jsid,
}

pub struct JSMutableHandleValue {
    unnamed: *JSVal,
}

pub type JSRawObject = *JSObject;

pub type JSPropertyOp = extern "C" fn(*JSContext, JSHandleObject, JSHandleId, JSMutableHandleValue) -> JSBool;

pub type JSStrictPropertyOp = extern "C" fn(*JSContext, JSHandleObject, JSHandleId, JSBool, JSMutableHandleValue) -> JSBool;

pub type JSNewEnumerateOp = *u8;

pub type JSEnumerateOp = extern "C" fn(*JSContext, JSHandleObject) -> JSBool;

pub type JSResolveOp = extern "C" fn(*JSContext, JSHandleObject, JSHandleId) -> JSBool;

pub type JSNewResolveOp = *u8;

pub type JSConvertOp = extern "C" fn(*JSContext, JSHandleObject, JSType, JSMutableHandleValue) -> JSBool;

pub type JSTypeOfOp = *u8;

pub type JSFreeOp = struct_JSFreeOp;

pub struct struct_JSFreeOp {
    runtime: *JSRuntime,
}

pub type JSFinalizeOp = extern "C" fn(*JSFreeOp, *JSObject);

pub type JSStringFinalizer = struct_JSStringFinalizer;

pub struct struct_JSStringFinalizer {
    finalize: *u8,
}

//XXXjdm JSAccessMode is an enum; uint32_t may not be correct.
pub type JSCheckAccessOp = extern "C" fn(*JSContext, **JSObject, *jsid, uint32_t, *mut JSVal) -> JSBool;

pub type JSHasInstanceOp = extern "C" fn(*JSContext, **JSObject, *JSVal, *mut JSBool) -> JSBool;

pub type JSTraceOp = extern "C" fn(*mut JSTracer, *JSObject);

pub type JSTraceNamePrinter = *u8;

pub type JSEqualityOp = *u8;

pub type JSNative = extern "C" fn(*JSContext, c_uint, *mut JSVal) -> JSBool;

pub type enum_JSContextOp = c_uint;
pub static JSCONTEXT_NEW: u32 = 0_u32;
pub static JSCONTEXT_DESTROY: u32 = 1_u32;

pub type JSContextOp = enum_JSContextOp;

pub type JSContextCallback = *u8;

pub type enum_JSGCStatus = c_uint;
pub static JSGC_BEGIN: u32 = 0_u32;
pub static JSGC_END: u32 = 1_u32;

pub type JSGCStatus = enum_JSGCStatus;

pub type JSGCCallback = extern "C" fn(*JSRuntime, JSGCStatus);

pub type enum_JSFinalizeStatus = c_uint;
pub static JSFINALIZE_START: u32 = 0_u32;
pub static JSFINALIZE_END: u32 = 1_u32;

pub type JSFinalizeStatus = enum_JSFinalizeStatus;

pub type JSFinalizeCallback = *u8;

pub type JSTraceDataOp = *u8;

pub type JSOperationCallback = *u8;

pub type JSErrorReporter = extern "C" fn(*JSContext, *c_char, *JSErrorReport);

pub type enum_JSExnType = c_int;
pub static JSEXN_NONE: i32 = -1_i32;
pub static JSEXN_ERR: i32 = 0_i32;
pub static JSEXN_INTERNALERR: i32 = 1_i32;
pub static JSEXN_EVALERR: i32 = 2_i32;
pub static JSEXN_RANGEERR: i32 = 3_i32;
pub static JSEXN_REFERENCEERR: i32 = 4_i32;
pub static JSEXN_SYNTAXERR: i32 = 5_i32;
pub static JSEXN_TYPEERR: i32 = 6_i32;
pub static JSEXN_URIERR: i32 = 7_i32;
pub static JSEXN_LIMIT: i32 = 8_i32;

pub type JSExnType = enum_JSExnType;

pub struct struct_JSErrorFormatString {
    format: *c_char,
    argCount: uint16_t,
    exnType: int16_t,
}

pub type JSErrorFormatString = struct_JSErrorFormatString;

pub type JSErrorCallback = *u8;

pub type JSLocaleToUpperCase = *u8;

pub type JSLocaleToLowerCase = *u8;

pub type JSLocaleCompare = *u8;

pub type JSLocaleToUnicode = *u8;

pub type JSDestroyPrincipalsOp = *u8;

pub type JSSubsumePrincipalsOp = *u8;

pub type JSObjectPrincipalsFinder = *u8;

pub type JSCSPEvalChecker = *u8;

pub type JSWrapObjectCallback = *u8;

pub type JSPreWrapCallback = *u8;

pub type JSSameCompartmentWrapObjectCallback = *u8;

pub type JSDestroyCompartmentCallback = *u8;

pub type JSCompartmentNameCallback = *u8;

pub type ReadStructuredCloneOp = *u8;

pub type WriteStructuredCloneOp = *u8;

pub type StructuredCloneErrorOp = *u8;

/* FIXME: global variable JSVAL_NULL */

/* FIXME: global variable JSVAL_ZERO */

/* FIXME: global variable JSVAL_ONE */

/* FIXME: global variable JSVAL_FALSE */

/* FIXME: global variable JSVAL_TRUE */

/* FIXME: global variable JSVAL_VOID */

pub type JSIterateCompartmentCallback = *u8;

pub type JSEnumerateDiagnosticMemoryCallback = *u8;

pub type enum_JSGCRootType = c_uint;
pub static JS_GC_ROOT_VALUE_PTR: u32 = 0_u32;
pub static JS_GC_ROOT_GCTHING_PTR: u32 = 1_u32;

pub type JSGCRootType = enum_JSGCRootType;

pub type JSGCRootMapFun = *u8;

pub type JSTraceCallback = *u8;

pub struct struct_JSTracer {
    runtime: *JSRuntime,
    callback: JSTraceCallback,
    debugPrinter: JSTraceNamePrinter,
    debugPrintArg: *c_void,
    debugPrintIndex: size_t,
    eagerlyTraceWeakMaps: JSBool,
}

pub type enum_JSGCParamKey = c_uint;
pub static JSGC_MAX_BYTES: u32 = 0_u32;
pub static JSGC_MAX_MALLOC_BYTES: u32 = 1_u32;
pub static JSGC_BYTES: u32 = 3_u32;
pub static JSGC_NUMBER: u32 = 4_u32;
pub static JSGC_MAX_CODE_CACHE_BYTES: u32 = 5_u32;
pub static JSGC_MODE: u32 = 6_u32;
pub static JSGC_UNUSED_CHUNKS: u32 = 7_u32;
pub static JSGC_TOTAL_CHUNKS: u32 = 8_u32;
pub static JSGC_SLICE_TIME_BUDGET: u32 = 9_u32;
pub static JSGC_MARK_STACK_LIMIT: u32 = 10_u32;
pub static JSGC_HIGH_FREQUENCY_TIME_LIMIT: u32 = 11_u32;
pub static JSGC_HIGH_FREQUENCY_LOW_LIMIT: u32 = 12_u32;
pub static JSGC_HIGH_FREQUENCY_HIGH_LIMIT: u32 = 13_u32;
pub static JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MAX: u32 = 14_u32;
pub static JSGC_HIGH_FREQUENCY_HEAP_GROWTH_MIN: u32 = 15_u32;
pub static JSGC_LOW_FREQUENCY_HEAP_GROWTH: u32 = 16_u32;
pub static JSGC_DYNAMIC_HEAP_GROWTH: u32 = 17_u32;
pub static JSGC_DYNAMIC_MARK_SLICE: u32 = 18_u32;
pub static JSGC_ANALYSIS_PURGE_TRIGGER: u32 = 19_u32;

pub type JSGCParamKey = enum_JSGCParamKey;

pub type enum_JSGCMode = c_uint;
pub static JSGC_MODE_GLOBAL: u32 = 0_u32;
pub static JSGC_MODE_COMPARTMENT: u32 = 1_u32;
pub static JSGC_MODE_INCREMENTAL: u32 = 2_u32;

pub type JSGCMode = enum_JSGCMode;

pub type JSClassInternal = *u8;

pub struct JSClass {
    name: *c_char,
    flags: uint32_t,
    addProperty: Option<JSPropertyOp>,
    delProperty: Option<JSPropertyOp>,
    getProperty: Option<JSPropertyOp>,
    setProperty: Option<JSStrictPropertyOp>,
    enumerate: Option<JSEnumerateOp>,
    resolve: Option<JSResolveOp>,
    convert: Option<JSConvertOp>,
    finalize: Option<JSFinalizeOp>,
    checkAccess: Option<JSCheckAccessOp>,
    call: Option<JSNative>,
    hasInstance: Option<JSHasInstanceOp>,
    construct: Option<JSNative>,
    trace: Option<JSTraceOp>,
    reserved: (*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void,*c_void),
}

pub struct struct_JSConstDoubleSpec {
    dval: c_double,
    name: *c_char,
    flags: uint8_t,
    spare: (uint8_t,uint8_t,uint8_t),
}

pub type struct_JSJitInfo = c_void;

//pub type JSJitInfo = struct_JSJitInfo; //XXXjdm

// FIXME: We need these Clone impls for certain operations in Servo,
// but do they really make sense?
pub struct JSStrictPropertyOpWrapper {
    op: Option<JSNative>,
    info: *JSJitInfo,
}

impl Clone for JSStrictPropertyOpWrapper {
    fn clone(&self) -> JSStrictPropertyOpWrapper {
        JSStrictPropertyOpWrapper {
            op: self.op,
            info: self.info
        }
    }
}

pub struct JSPropertyOpWrapper {
    op: Option<JSNative>,
    info: *JSJitInfo,
}

impl Clone for JSPropertyOpWrapper {
    fn clone(&self) -> JSPropertyOpWrapper {
        JSPropertyOpWrapper {
            op: self.op,
            info: self.info
        }
    }
}

pub struct JSNativeWrapper {
    op: Option<JSNative>,
    info: *JSJitInfo,
}

impl Clone for JSNativeWrapper {
    fn clone(&self) -> JSNativeWrapper {
        JSNativeWrapper {
            op: self.op,
            info: self.info
        }
    }
}

#[deriving(Clone)]
pub struct JSPropertySpec {
    name: *c_char,
    tinyid: int8_t,
    flags: uint8_t,
    getter: JSPropertyOpWrapper,
    setter: JSStrictPropertyOpWrapper,
}

#[deriving(Clone)]
pub struct JSFunctionSpec {
    name: *c_char,
    call: JSNativeWrapper,
    nargs: uint16_t,
    flags: uint16_t,
    selfHostedName: *c_char,
}

pub struct struct_JSPropertyDescriptor {
    obj: *JSObject,
    attrs: c_uint,
    shortid: c_uint,
    getter: Option<JSPropertyOp>,
    setter: Option<JSStrictPropertyOp>,
    value: JSVal,
}

pub struct struct_JSPrincipals {
    refcount: c_int,
}

pub struct struct_JSSecurityCallbacks {
    checkObjectAccess: JSCheckAccessOp,
    subsumePrincipals: JSSubsumePrincipalsOp,
    findObjectPrincipals: JSObjectPrincipalsFinder,
    contentSecurityPolicyAllows: JSCSPEvalChecker,
}

pub type enum_JSExecPart = c_uint;
pub static JSEXEC_PROLOG: u32 = 0_u32;
pub static JSEXEC_MAIN: u32 = 1_u32;

pub type JSExecPart = enum_JSExecPart;

pub type JSONWriteCallback = *u8;

pub struct struct_JSStructuredCloneCallbacks {
    read: ReadStructuredCloneOp,
    write: WriteStructuredCloneOp,
    reportError: StructuredCloneErrorOp,
}

pub struct struct_JSLocaleCallbacks {
    localeToUpperCase: JSLocaleToUpperCase,
    localeToLowerCase: JSLocaleToLowerCase,
    localeCompare: JSLocaleCompare,
    localeToUnicode: JSLocaleToUnicode,
    localeGetErrorMessage: JSErrorCallback,
}

pub struct struct_JSErrorReport {
    filename: *c_char,
    originPrincipals: *JSPrincipals,
    lineno: c_uint,
    linebuf: *c_char,
    tokenptr: *c_char,
    uclinebuf: *jschar,
    uctokenptr: *jschar,
    flags: c_uint,
    errorNumber: c_uint,
    ucmessage: *jschar,
    messageArgs: **jschar,
    exnType: int16_t,
    column: c_uint,
}

pub struct struct_unnamed1 {
    payload: union_unnamed2,
}

pub type union_unnamed2 = c_void /* FIXME: union type */;

#[nolink]
extern {

pub fn JS_Assert(s: *c_char, file: *c_char, ln: c_int);

//fn JS_Abort();

//fn JS_CreateHandleObject(cx: *JSContext, obj: *JSObject, phandle: *JSHandleObject) -> JSBool;

//fn JS_DestroyHandleObject(cx: *JSContext, handle: JSHandleObject);

//fn JS_CreateMutableHandleObject(cx: *JSContext, obj: *JSObject, phandle: *JSMutableHandleObject) -> JSBool;

//fn JS_DestroyMutableHandleObject(cx: *JSContext, handle: JSMutableHandleObject);

//fn JS_CreateHandleId(cx: *JSContext, id: jsid, phandle: *JSHandleId) -> JSBool;

//fn JS_DestroyHandleId(cx: *JSContext, handle: JSHandleId);

pub fn JS_StringHasBeenInterned(cx: *JSContext, str: *JSString) -> JSBool;

pub fn INTERNED_STRING_TO_JSID(cx: *JSContext, str: *JSString) -> jsid;

pub fn JS_CallOnce(once_: *JSCallOnceType, func: JSInitCallback) -> JSBool;

pub fn JS_Now() -> int64_t;

pub fn JS_GetNaNValue(cx: *JSContext) -> JSVal;

pub fn JS_GetNegativeInfinityValue(cx: *JSContext) -> JSVal;

pub fn JS_GetPositiveInfinityValue(cx: *JSContext) -> JSVal;

pub fn JS_GetEmptyStringValue(cx: *JSContext) -> JSVal;

pub fn JS_GetEmptyString(rt: *JSRuntime) -> *JSString;

pub fn JS_ConvertArguments(cx: *JSContext, argc: c_uint, argv: *JSVal, format: *c_char/* FIXME: variadic function */) -> JSBool;

pub fn JS_ConvertValue(cx: *JSContext, v: JSVal, _type: JSType, vp: *JSVal) -> JSBool;

pub fn JS_ValueToObject(cx: *JSContext, v: JSVal, objp: **JSObject) -> JSBool;

pub fn JS_ValueToFunction(cx: *JSContext, v: JSVal) -> *JSFunction;

pub fn JS_ValueToConstructor(cx: *JSContext, v: JSVal) -> *JSFunction;

pub fn JS_ValueToString(cx: *JSContext, v: JSVal) -> *JSString;

pub fn JS_ValueToSource(cx: *JSContext, v: JSVal) -> *JSString;

pub fn JS_ValueToNumber(cx: *JSContext, v: JSVal, dp: *c_double) -> JSBool;

pub fn JS_DoubleIsInt32(d: c_double, ip: *int32_t) -> JSBool;

pub fn JS_DoubleToInt32(d: c_double) -> int32_t;

pub fn JS_DoubleToUint32(d: c_double) -> uint32_t;

pub fn JS_ValueToECMAInt32(cx: *JSContext, v: JSVal, ip: *int32_t) -> JSBool;

pub fn JS_ValueToInt64(cx: *JSContext, v: JSVal, ip: *int64_t) -> JSBool;

pub fn JS_ValueToUint64(cx: *JSContext, v: JSVal, ip: *uint64_t) -> JSBool;

pub fn JS_ValueToECMAUint32(cx: *JSContext, v: JSVal, ip: *uint32_t) -> JSBool;

pub fn JS_ValueToInt32(cx: *JSContext, v: JSVal, ip: *int32_t) -> JSBool;

pub fn JS_ValueToUint16(cx: *JSContext, v: JSVal, ip: *uint16_t) -> JSBool;

pub fn JS_ValueToBoolean(cx: *JSContext, v: JSVal, bp: *JSBool) -> JSBool;

pub fn JS_TypeOfValue(cx: *JSContext, v: JSVal) -> JSType;

pub fn JS_GetTypeName(cx: *JSContext, _type: JSType) -> *c_char;

pub fn JS_StrictlyEqual(cx: *JSContext, v1: JSVal, v2: JSVal, equal: *JSBool) -> JSBool;

pub fn JS_LooselyEqual(cx: *JSContext, v1: JSVal, v2: JSVal, equal: *JSBool) -> JSBool;

pub fn JS_SameValue(cx: *JSContext, v1: JSVal, v2: JSVal, same: *JSBool) -> JSBool;

pub fn JS_IsBuiltinEvalFunction(fun: *JSFunction) -> JSBool;

pub fn JS_IsBuiltinFunctionConstructor(fun: *JSFunction) -> JSBool;

pub fn JS_Init(maxbytes: uint32_t) -> *JSRuntime;

pub fn JS_Finish(rt: *JSRuntime);

pub fn JS_ShutDown();

pub fn JS_GetRuntimePrivate(rt: *JSRuntime) -> *c_void;

pub fn JS_GetRuntime(cx: *JSContext) -> *JSRuntime;

pub fn JS_SetRuntimePrivate(rt: *JSRuntime, data: *c_void);

pub fn JS_BeginRequest(cx: *JSContext);

pub fn JS_EndRequest(cx: *JSContext);

pub fn JS_YieldRequest(cx: *JSContext);

pub fn JS_SuspendRequest(cx: *JSContext) -> c_uint;

pub fn JS_ResumeRequest(cx: *JSContext, saveDepth: c_uint);

pub fn JS_IsInRequest(rt: *JSRuntime) -> JSBool;

pub fn JS_IsInSuspendedRequest(rt: *JSRuntime) -> JSBool;

pub fn JS_SetContextCallback(rt: *JSRuntime, cxCallback: JSContextCallback) -> JSContextCallback;

pub fn JS_NewContext(rt: *JSRuntime, stackChunkSize: size_t) -> *JSContext;

pub fn JS_DestroyContext(cx: *JSContext);

pub fn JS_DestroyContextNoGC(cx: *JSContext);

pub fn JS_GetContextPrivate(cx: *JSContext) -> *c_void;

pub fn JS_SetContextPrivate(cx: *JSContext, data: *c_void);

pub fn JS_GetSecondContextPrivate(cx: *JSContext) -> *c_void;

pub fn JS_SetSecondContextPrivate(cx: *JSContext, data: *c_void);

pub fn JS_ContextIterator(rt: *JSRuntime, iterp: **JSContext) -> *JSContext;

pub fn JS_GetVersion(cx: *JSContext) -> JSVersion;

pub fn JS_SetVersion(cx: *JSContext, version: JSVersion) -> JSVersion;

pub fn JS_VersionToString(version: JSVersion) -> *c_char;

pub fn JS_StringToVersion(string: *c_char) -> JSVersion;

pub fn JS_GetOptions(cx: *JSContext) -> uint32_t;

pub fn JS_SetOptions(cx: *JSContext, options: uint32_t) -> uint32_t;

pub fn JS_ToggleOptions(cx: *JSContext, options: uint32_t) -> uint32_t;

pub fn JS_SetJitHardening(rt: *JSRuntime, enabled: JSBool);

pub fn JS_GetImplementationVersion() -> *c_char;

pub fn JS_SetDestroyCompartmentCallback(rt: *JSRuntime, callback: JSDestroyCompartmentCallback);

pub fn JS_SetCompartmentNameCallback(rt: *JSRuntime, callback: JSCompartmentNameCallback);

pub fn JS_SetWrapObjectCallbacks(rt: *JSRuntime, callback: JSWrapObjectCallback, sccallback: JSSameCompartmentWrapObjectCallback, precallback: JSPreWrapCallback) -> JSWrapObjectCallback;

pub fn JS_EnterCrossCompartmentCall(cx: *JSContext, target: JSRawObject) -> *JSCrossCompartmentCall;

pub fn JS_LeaveCrossCompartmentCall(call: *JSCrossCompartmentCall);

pub fn JS_SetCompartmentPrivate(compartment: *JSCompartment, data: *c_void);

pub fn JS_GetCompartmentPrivate(compartment: *JSCompartment) -> *c_void;

pub fn JS_WrapObject(cx: *JSContext, objp: **JSObject) -> JSBool;

pub fn JS_WrapValue(cx: *JSContext, vp: *JSVal) -> JSBool;

pub fn JS_TransplantObject(cx: *JSContext, origobj: *JSObject, target: *JSObject) -> *JSObject;

pub fn js_TransplantObjectWithWrapper(cx: *JSContext, origobj: *JSObject, origwrapper: *JSObject, targetobj: *JSObject, targetwrapper: *JSObject) -> *JSObject;

pub fn JS_RefreshCrossCompartmentWrappers(cx: *JSContext, ob: *JSObject) -> JSBool;

pub fn JS_IterateCompartments(rt: *JSRuntime, data: *c_void, compartmentCallback: JSIterateCompartmentCallback);

pub fn JS_GetGlobalObject(cx: *JSContext) -> *JSObject;

pub fn JS_SetGlobalObject(cx: *JSContext, obj: JSRawObject);

pub fn JS_InitStandardClasses(cx: *JSContext, obj: *JSObject) -> JSBool;

pub fn JS_ResolveStandardClass(cx: *JSContext, obj: *JSObject, id: jsid, resolved: *JSBool) -> JSBool;

pub fn JS_EnumerateStandardClasses(cx: *JSContext, obj: *JSObject) -> JSBool;

pub fn JS_EnumerateResolvedStandardClasses(cx: *JSContext, obj: *JSObject, ida: *JSIdArray) -> *JSIdArray;

pub fn JS_GetClassObject(cx: *JSContext, obj: JSRawObject, key: JSProtoKey, objp: **JSObject) -> JSBool;

pub fn JS_GetClassPrototype(cx: *JSContext, key: JSProtoKey, objp: **JSObject) -> JSBool;

pub fn JS_IdentifyClassPrototype(cx: *JSContext, obj: *JSObject) -> JSProtoKey;

pub fn JS_GetFunctionPrototype(cx: *JSContext, forObj: JSRawObject) -> *JSObject;

pub fn JS_GetObjectPrototype(cx: *JSContext, forObj: JSRawObject) -> *JSObject;

pub fn JS_GetGlobalForObject(cx: *JSContext, obj: JSRawObject) -> *JSObject;

pub fn JS_GetGlobalForCompartmentOrNull(cx: *JSContext, c: *JSCompartment) -> *JSObject;

pub fn JS_GetGlobalForScopeChain(cx: *JSContext) -> *JSObject;

pub fn JS_GetScriptedGlobal(cx: *JSContext) -> *JSObject;

pub fn JS_InitReflect(cx: *JSContext, global: *JSObject) -> *JSObject;

pub fn JS_EnumerateDiagnosticMemoryRegions(callback: JSEnumerateDiagnosticMemoryCallback);

// FIXME: Couldn't run on rust_stack until rust issue #6470 fixed.
//#[rust_stack]
pub fn JS_ComputeThis(cx: *JSContext, vp: *JSVal) -> JSVal;

pub fn JS_MallocInCompartment(comp: *JSCompartment, nbytes: size_t);

pub fn JS_FreeInCompartment(comp: *JSCompartment, nbytes: size_t);

pub fn JS_malloc(cx: *JSContext, nbytes: size_t) -> *c_void;

pub fn JS_realloc(cx: *JSContext, p: *c_void, nbytes: size_t) -> *c_void;

pub fn JS_free(cx: *JSContext, p: *c_void);

pub fn JS_freeop(fop: *JSFreeOp, p: *c_void);

pub fn JS_GetDefaultFreeOp(rt: *JSRuntime) -> *JSFreeOp;

pub fn JS_updateMallocCounter(cx: *JSContext, nbytes: size_t);

pub fn JS_strdup(cx: *JSContext, s: *c_char) -> *c_char;

pub fn JS_AddValueRoot(cx: *JSContext, vp: *JSVal) -> JSBool;

pub fn JS_AddStringRoot(cx: *JSContext, rp: **JSString) -> JSBool;

pub fn JS_AddObjectRoot(cx: *JSContext, rp: **JSObject) -> JSBool;

pub fn JS_AddGCThingRoot(cx: *JSContext, rp: **c_void) -> JSBool;

pub fn JS_AddNamedValueRoot(cx: *JSContext, vp: *JSVal, name: *c_char) -> JSBool;

pub fn JS_AddNamedStringRoot(cx: *JSContext, rp: **JSString, name: *c_char) -> JSBool;

pub fn JS_AddNamedObjectRoot(cx: *JSContext, rp: **JSObject, name: *c_char) -> JSBool;

pub fn JS_AddNamedScriptRoot(cx: *JSContext, rp: **JSScript, name: *c_char) -> JSBool;

pub fn JS_AddNamedGCThingRoot(cx: *JSContext, rp: **c_void, name: *c_char) -> JSBool;

pub fn JS_RemoveValueRoot(cx: *JSContext, vp: *JSVal);

pub fn JS_RemoveStringRoot(cx: *JSContext, rp: **JSString);

pub fn JS_RemoveObjectRoot(cx: *JSContext, rp: **JSObject);

pub fn JS_RemoveScriptRoot(cx: *JSContext, rp: **JSScript);

pub fn JS_RemoveGCThingRoot(cx: *JSContext, rp: **c_void);

pub fn JS_RemoveValueRootRT(rt: *JSRuntime, vp: *JSVal);

pub fn JS_RemoveStringRootRT(rt: *JSRuntime, rp: **JSString);

pub fn JS_RemoveObjectRootRT(rt: *JSRuntime, rp: **JSObject);

pub fn js_AddRootRT(rt: *JSRuntime, vp: *JSVal, name: *c_char) -> JSBool;

pub fn js_AddGCThingRootRT(rt: *JSRuntime, rp: **c_void, name: *c_char) -> JSBool;

pub fn js_RemoveRoot(rt: *JSRuntime, rp: *c_void);

pub fn JS_AnchorPtr(p: *c_void);

pub fn JS_MapGCRoots(rt: *JSRuntime, map: JSGCRootMapFun, data: *c_void) -> uint32_t;

pub fn JS_LockGCThing(cx: *JSContext, thing: *c_void) -> JSBool;

pub fn JS_LockGCThingRT(rt: *JSRuntime, thing: *c_void) -> JSBool;

pub fn JS_UnlockGCThing(cx: *JSContext, thing: *c_void) -> JSBool;

pub fn JS_UnlockGCThingRT(rt: *JSRuntime, thing: *c_void) -> JSBool;

pub fn JS_SetExtraGCRootsTracer(rt: *JSRuntime, traceOp: JSTraceDataOp, data: *c_void);

pub fn JS_CallTracer(trc: *JSTracer, thing: *c_void, kind: JSGCTraceKind);

pub fn JS_TracerInit(trc: *JSTracer, rt: *JSRuntime, callback: JSTraceCallback);

pub fn JS_TraceChildren(trc: *JSTracer, thing: *c_void, kind: JSGCTraceKind);

pub fn JS_TraceRuntime(trc: *JSTracer);

pub fn JS_GetTraceThingInfo(buf: *c_char, bufsize: size_t, trc: *JSTracer, thing: *c_void, kind: JSGCTraceKind, includeDetails: JSBool);

pub fn JS_GetTraceEdgeName(trc: *JSTracer, buffer: *c_char, bufferSize: c_int) -> *c_char;

pub fn JS_GC(rt: *JSRuntime);

pub fn JS_MaybeGC(cx: *JSContext);

pub fn JS_SetGCCallback(rt: *JSRuntime, cb: JSGCCallback);

pub fn JS_SetFinalizeCallback(rt: *JSRuntime, cb: JSFinalizeCallback);

pub fn JS_IsGCMarkingTracer(trc: *JSTracer) -> JSBool;

pub fn JS_IsAboutToBeFinalized(thing: *c_void) -> JSBool;

pub fn JS_SetGCParameter(rt: *JSRuntime, key: JSGCParamKey, value: uint32_t);

pub fn JS_GetGCParameter(rt: *JSRuntime, key: JSGCParamKey) -> uint32_t;

pub fn JS_SetGCParameterForThread(cx: *JSContext, key: JSGCParamKey, value: uint32_t);

pub fn JS_GetGCParameterForThread(cx: *JSContext, key: JSGCParamKey) -> uint32_t;

pub fn JS_NewExternalString(cx: *JSContext, chars: *jschar, length: size_t, fin: *JSStringFinalizer) -> *JSString;

pub fn JS_IsExternalString(str: *JSString) -> JSBool;

pub fn JS_GetExternalStringFinalizer(str: *JSString) -> *JSStringFinalizer;

pub fn JS_SetNativeStackQuota(cx: *JSRuntime, stackSize: size_t);

pub fn JS_IdArrayLength(cx: *JSContext, ida: *JSIdArray) -> c_int;

pub fn JS_IdArrayGet(cx: *JSContext, ida: *JSIdArray, index: c_int) -> jsid;

pub fn JS_DestroyIdArray(cx: *JSContext, ida: *JSIdArray);

pub fn JS_ValueToId(cx: *JSContext, v: JSVal, idp: *jsid) -> JSBool;

pub fn JS_IdToValue(cx: *JSContext, id: jsid, vp: *JSVal) -> JSBool;

pub fn JS_DefaultValue(cx: *JSContext, obj: *JSObject, hint: JSType, vp: *JSVal) -> JSBool;

pub fn JS_PropertyStub(cx: *JSContext, obj: JSHandleObject, id: JSHandleId, vp: JSMutableHandleValue) -> JSBool;

pub fn JS_StrictPropertyStub(cx: *JSContext, obj: JSHandleObject, id: JSHandleId, strict: JSBool, vp: JSMutableHandleValue) -> JSBool;

pub fn JS_EnumerateStub(cx: *JSContext, obj: JSHandleObject) -> JSBool;

pub fn JS_ResolveStub(cx: *JSContext, obj: JSHandleObject, id: JSHandleId) -> JSBool;

pub fn JS_ConvertStub(cx: *JSContext, obj: JSHandleObject, _type: JSType, vp: JSMutableHandleValue) -> JSBool;

pub fn JS_InitClass(cx: *JSContext, obj: *JSObject, parent_proto: *JSObject, clasp: *JSClass, constructor: JSNative, nargs: c_uint, ps: *JSPropertySpec, fs: *JSFunctionSpec, static_ps: *JSPropertySpec, static_fs: *JSFunctionSpec) -> *JSObject;

pub fn JS_LinkConstructorAndPrototype(cx: *JSContext, ctor: *JSObject, proto: *JSObject) -> JSBool;

pub fn JS_GetClass(obj: JSRawObject) -> *JSClass;

pub fn JS_InstanceOf(cx: *JSContext, obj: *JSObject, clasp: *JSClass, argv: *JSVal) -> JSBool;

pub fn JS_HasInstance(cx: *JSContext, obj: *JSObject, v: JSVal, bp: *JSBool) -> JSBool;

pub fn JS_GetPrivate(obj: JSRawObject) -> *c_void;

pub fn JS_SetPrivate(obj: JSRawObject, data: *c_void);

pub fn JS_GetInstancePrivate(cx: *JSContext, obj: *JSObject, clasp: *JSClass, argv: *JSVal) -> *c_void;

pub fn JS_GetPrototype(obj: JSRawObject) -> *JSObject;

pub fn JS_SetPrototype(cx: *JSContext, obj: *JSObject, proto: *JSObject) -> JSBool;

pub fn JS_GetParent(obj: JSRawObject) -> *JSObject;

pub fn JS_SetParent(cx: *JSContext, obj: *JSObject, parent: *JSObject) -> JSBool;

pub fn JS_GetConstructor(cx: *JSContext, proto: *JSObject) -> *JSObject;

pub fn JS_GetObjectId(cx: *JSContext, obj: JSRawObject, idp: *jsid) -> JSBool;

pub fn JS_NewGlobalObject(cx: *JSContext, clasp: *JSClass, principals: *JSPrincipals) -> *JSObject;

pub fn JS_NewObject(cx: *JSContext, clasp: *JSClass, proto: *JSObject, parent: *JSObject) -> *JSObject;

pub fn JS_IsExtensible(obj: JSRawObject) -> JSBool;

pub fn JS_IsNative(obj: JSRawObject) -> JSBool;

pub fn JS_GetObjectRuntime(obj: JSRawObject) -> *JSRuntime;

pub fn JS_NewObjectWithGivenProto(cx: *JSContext, clasp: *JSClass, proto: *JSObject, parent: *JSObject) -> *JSObject;

pub fn JS_DeepFreezeObject(cx: *JSContext, obj: *JSObject) -> JSBool;

pub fn JS_FreezeObject(cx: *JSContext, obj: *JSObject) -> JSBool;

pub fn JS_New(cx: *JSContext, ctor: *JSObject, argc: c_uint, argv: *JSVal) -> *JSObject;

pub fn JS_DefineObject(cx: *JSContext, obj: *JSObject, name: *c_char, clasp: *JSClass, proto: *JSObject, attrs: c_uint) -> *JSObject;

pub fn JS_DefineConstDoubles(cx: *JSContext, obj: *JSObject, cds: *JSConstDoubleSpec) -> JSBool;

pub fn JS_DefineProperties(cx: *JSContext, obj: *JSObject, ps: *JSPropertySpec) -> JSBool;

pub fn JS_DefineProperty(cx: *JSContext, obj: *JSObject, name: *c_char, value: JSVal, getter: Option<JSPropertyOp>, setter: Option<JSStrictPropertyOp>, attrs: c_uint) -> JSBool;

pub fn JS_DefinePropertyById(cx: *JSContext, obj: *JSObject, id: jsid, value: JSVal, getter: Option<JSPropertyOp>, setter: Option<JSStrictPropertyOp>, attrs: c_uint) -> JSBool;

pub fn JS_DefineOwnProperty(cx: *JSContext, obj: *JSObject, id: jsid, descriptor: JSVal, bp: *JSBool) -> JSBool;

pub fn JS_GetPropertyAttributes(cx: *JSContext, obj: *JSObject, name: *c_char, attrsp: *c_uint, foundp: *JSBool) -> JSBool;

pub fn JS_GetPropertyAttrsGetterAndSetter(cx: *JSContext, obj: *JSObject, name: *c_char, attrsp: *c_uint, foundp: *JSBool, getterp: *JSPropertyOp, setterp: *JSStrictPropertyOp) -> JSBool;

pub fn JS_GetPropertyAttrsGetterAndSetterById(cx: *JSContext, obj: *JSObject, id: jsid, attrsp: *c_uint, foundp: *JSBool, getterp: *JSPropertyOp, setterp: *JSStrictPropertyOp) -> JSBool;

pub fn JS_SetPropertyAttributes(cx: *JSContext, obj: *JSObject, name: *c_char, attrs: c_uint, foundp: *JSBool) -> JSBool;

pub fn JS_DefinePropertyWithTinyId(cx: *JSContext, obj: *JSObject, name: *c_char, tinyid: int8_t, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_AlreadyHasOwnProperty(cx: *JSContext, obj: *JSObject, name: *c_char, foundp: *JSBool) -> JSBool;

pub fn JS_AlreadyHasOwnPropertyById(cx: *JSContext, obj: *JSObject, id: jsid, foundp: *JSBool) -> JSBool;

pub fn JS_HasProperty(cx: *JSContext, obj: *JSObject, name: *c_char, foundp: *JSBool) -> JSBool;

pub fn JS_HasPropertyById(cx: *JSContext, obj: *JSObject, id: jsid, foundp: *JSBool) -> JSBool;

pub fn JS_LookupProperty(cx: *JSContext, obj: *JSObject, name: *c_char, vp: *JSVal) -> JSBool;

pub fn JS_LookupPropertyById(cx: *JSContext, obj: *JSObject, id: jsid, vp: *JSVal) -> JSBool;

pub fn JS_LookupPropertyWithFlags(cx: *JSContext, obj: *JSObject, name: *c_char, flags: c_uint, vp: *JSVal) -> JSBool;

pub fn JS_LookupPropertyWithFlagsById(cx: *JSContext, obj: *JSObject, id: jsid, flags: c_uint, objp: **JSObject, vp: *JSVal) -> JSBool;

pub fn JS_GetPropertyDescriptorById(cx: *JSContext, obj: *JSObject, id: jsid, flags: c_uint, desc: *JSPropertyDescriptor) -> JSBool;

pub fn JS_GetOwnPropertyDescriptor(cx: *JSContext, obj: *JSObject, id: jsid, vp: *JSVal) -> JSBool;

pub fn JS_GetProperty(cx: *JSContext, obj: *JSObject, name: *c_char, vp: *JSVal) -> JSBool;

pub fn JS_GetPropertyDefault(cx: *JSContext, obj: *JSObject, name: *c_char, def: JSVal, vp: *JSVal) -> JSBool;

pub fn JS_GetPropertyById(cx: *JSContext, obj: *JSObject, id: jsid, vp: *JSVal) -> JSBool;

pub fn JS_GetPropertyByIdDefault(cx: *JSContext, obj: *JSObject, id: jsid, def: JSVal, vp: *JSVal) -> JSBool;

pub fn JS_ForwardGetPropertyTo(cx: *JSContext, obj: *JSObject, id: jsid, onBehalfOf: *JSObject, vp: *JSVal) -> JSBool;

pub fn JS_GetMethodById(cx: *JSContext, obj: *JSObject, id: jsid, objp: **JSObject, vp: *JSVal) -> JSBool;

pub fn JS_GetMethod(cx: *JSContext, obj: *JSObject, name: *c_char, objp: **JSObject, vp: *JSVal) -> JSBool;

pub fn JS_SetProperty(cx: *JSContext, obj: *JSObject, name: *c_char, vp: *JSVal) -> JSBool;

pub fn JS_SetPropertyById(cx: *JSContext, obj: *JSObject, id: jsid, vp: *JSVal) -> JSBool;

pub fn JS_DeleteProperty(cx: *JSContext, obj: *JSObject, name: *c_char) -> JSBool;

pub fn JS_DeleteProperty2(cx: *JSContext, obj: *JSObject, name: *c_char, rval: *JSVal) -> JSBool;

pub fn JS_DeletePropertyById(cx: *JSContext, obj: *JSObject, id: jsid) -> JSBool;

pub fn JS_DeletePropertyById2(cx: *JSContext, obj: *JSObject, id: jsid, rval: *JSVal) -> JSBool;

pub fn JS_DefineUCProperty(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_GetUCPropertyAttributes(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, attrsp: *c_uint, foundp: *JSBool) -> JSBool;

pub fn JS_GetUCPropertyAttrsGetterAndSetter(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, attrsp: *c_uint, foundp: *JSBool, getterp: *JSPropertyOp, setterp: *JSStrictPropertyOp) -> JSBool;

pub fn JS_SetUCPropertyAttributes(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, attrs: c_uint, foundp: *JSBool) -> JSBool;

pub fn JS_DefineUCPropertyWithTinyId(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, tinyid: int8_t, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_AlreadyHasOwnUCProperty(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, foundp: *JSBool) -> JSBool;

pub fn JS_HasUCProperty(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, vp: *JSBool) -> JSBool;

pub fn JS_LookupUCProperty(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, vp: *JSVal) -> JSBool;

pub fn JS_GetUCProperty(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, vp: *JSVal) -> JSBool;

pub fn JS_SetUCProperty(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, vp: *JSVal) -> JSBool;

pub fn JS_DeleteUCProperty2(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, rval: *JSVal) -> JSBool;

pub fn JS_NewArrayObject(cx: *JSContext, length: c_int, vector: *JSVal) -> *JSObject;

pub fn JS_IsArrayObject(cx: *JSContext, obj: *JSObject) -> JSBool;

pub fn JS_GetArrayLength(cx: *JSContext, obj: *JSObject, lengthp: *uint32_t) -> JSBool;

pub fn JS_SetArrayLength(cx: *JSContext, obj: *JSObject, length: uint32_t) -> JSBool;

pub fn JS_DefineElement(cx: *JSContext, obj: *JSObject, index: uint32_t, value: JSVal, getter: JSPropertyOp, setter: JSStrictPropertyOp, attrs: c_uint) -> JSBool;

pub fn JS_AlreadyHasOwnElement(cx: *JSContext, obj: *JSObject, index: uint32_t, foundp: *JSBool) -> JSBool;

pub fn JS_HasElement(cx: *JSContext, obj: *JSObject, index: uint32_t, foundp: *JSBool) -> JSBool;

pub fn JS_LookupElement(cx: *JSContext, obj: *JSObject, index: uint32_t, vp: *JSVal) -> JSBool;

pub fn JS_GetElement(cx: *JSContext, obj: *JSObject, index: uint32_t, vp: *JSVal) -> JSBool;

pub fn JS_ForwardGetElementTo(cx: *JSContext, obj: *JSObject, index: uint32_t, onBehalfOf: *JSObject, vp: *JSVal) -> JSBool;

pub fn JS_GetElementIfPresent(cx: *JSContext, obj: *JSObject, index: uint32_t, onBehalfOf: *JSObject, vp: *JSVal, present: *JSBool) -> JSBool;

pub fn JS_SetElement(cx: *JSContext, obj: *JSObject, index: uint32_t, vp: *JSVal) -> JSBool;

pub fn JS_DeleteElement(cx: *JSContext, obj: *JSObject, index: uint32_t) -> JSBool;

pub fn JS_DeleteElement2(cx: *JSContext, obj: *JSObject, index: uint32_t, rval: *JSVal) -> JSBool;

pub fn JS_ClearScope(cx: *JSContext, obj: *JSObject);

pub fn JS_Enumerate(cx: *JSContext, obj: *JSObject) -> *JSIdArray;

pub fn JS_NewPropertyIterator(cx: *JSContext, obj: *JSObject) -> *JSObject;

pub fn JS_NextProperty(cx: *JSContext, iterobj: *JSObject, idp: *jsid) -> JSBool;

pub fn JS_ArrayIterator(cx: *JSContext, argc: c_uint, vp: *JSVal) -> JSBool;

pub fn JS_CheckAccess(cx: *JSContext, obj: *JSObject, id: jsid, mode: JSAccessMode, vp: *JSVal, attrsp: *c_uint) -> JSBool;

// FIXME: couldn't run on rust_stack until rust issue #6470 fixed.
//#[rust_stack]
pub fn JS_GetReservedSlot(obj: JSRawObject, index: uint32_t) -> JSVal;

pub fn JS_SetReservedSlot(obj: JSRawObject, index: uint32_t, v: JSVal);

pub fn JS_HoldPrincipals(principals: *JSPrincipals);

pub fn JS_DropPrincipals(rt: *JSRuntime, principals: *JSPrincipals);

pub fn JS_SetSecurityCallbacks(rt: *JSRuntime, callbacks: *JSSecurityCallbacks);

pub fn JS_GetSecurityCallbacks(rt: *JSRuntime) -> *JSSecurityCallbacks;

pub fn JS_SetTrustedPrincipals(rt: *JSRuntime, prin: *JSPrincipals);

pub fn JS_InitDestroyPrincipalsCallback(rt: *JSRuntime, destroyPrincipals: JSDestroyPrincipalsOp);

pub fn JS_NewFunction(cx: *JSContext, call: Option<JSNative>, nargs: c_uint, flags: c_uint, parent: *JSObject, name: *c_char) -> *JSFunction;

pub fn JS_NewFunctionById(cx: *JSContext, call: JSNative, nargs: c_uint, flags: c_uint, parent: *JSObject, id: jsid) -> *JSFunction;

pub fn JS_GetFunctionObject(fun: *JSFunction) -> *JSObject;

pub fn JS_GetFunctionId(fun: *JSFunction) -> *JSString;

pub fn JS_GetFunctionDisplayId(fun: *JSFunction) -> *JSString;

pub fn JS_GetFunctionFlags(fun: *JSFunction) -> c_uint;

pub fn JS_GetFunctionArity(fun: *JSFunction) -> uint16_t;

pub fn JS_ObjectIsFunction(cx: *JSContext, obj: JSRawObject) -> JSBool;

pub fn JS_ObjectIsCallable(cx: *JSContext, obj: JSRawObject) -> JSBool;

pub fn JS_IsNativeFunction(funobj: JSRawObject, call: JSNative) -> JSBool;

pub fn JS_BindCallable(cx: *JSContext, callable: *JSObject, newThis: JSRawObject) -> *JSObject;

pub fn JS_DefineFunctions(cx: *JSContext, obj: *JSObject, fs: *JSFunctionSpec) -> JSBool;

pub fn JS_DefineFunction(cx: *JSContext, obj: *JSObject, name: *c_char, call: JSNative, nargs: c_uint, attrs: c_uint) -> *JSFunction;

pub fn JS_DefineUCFunction(cx: *JSContext, obj: *JSObject, name: *jschar, namelen: size_t, call: JSNative, nargs: c_uint, attrs: c_uint) -> *JSFunction;

pub fn JS_DefineFunctionById(cx: *JSContext, obj: *JSObject, id: jsid, call: JSNative, nargs: c_uint, attrs: c_uint) -> *JSFunction;

pub fn JS_CloneFunctionObject(cx: *JSContext, funobj: *JSObject, parent: JSRawObject) -> *JSObject;

pub fn JS_BufferIsCompilableUnit(cx: *JSContext, bytes_are_utf8: JSBool, obj: *JSObject, bytes: *c_char, length: size_t) -> JSBool;

pub fn JS_CompileScript(cx: *JSContext, obj: *JSObject, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint) -> *JSScript;

pub fn JS_CompileScriptForPrincipals(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint) -> *JSScript;

pub fn JS_CompileScriptForPrincipalsVersion(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint, version: JSVersion) -> *JSScript;

pub fn JS_CompileUCScript(cx: *JSContext, obj: *JSObject, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint) -> *JSScript;

pub fn JS_CompileUCScriptForPrincipals(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint) -> *JSScript;

pub fn JS_CompileUCScriptForPrincipalsVersion(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint, version: JSVersion) -> *JSScript;

pub fn JS_CompileUCScriptForPrincipalsVersionOrigin(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, originPrincipals: *JSPrincipals, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint, version: JSVersion) -> *JSScript;

pub fn JS_CompileUTF8File(cx: *JSContext, obj: *JSObject, filename: *c_char) -> *JSScript;

pub fn JS_CompileUTF8FileHandle(cx: *JSContext, obj: *JSObject, filename: *c_char, fh: *FILE) -> *JSScript;

pub fn JS_CompileUTF8FileHandleForPrincipals(cx: *JSContext, obj: *JSObject, filename: *c_char, fh: *FILE, principals: *JSPrincipals) -> *JSScript;

pub fn JS_CompileUTF8FileHandleForPrincipalsVersion(cx: *JSContext, obj: *JSObject, filename: *c_char, fh: *FILE, principals: *JSPrincipals, version: JSVersion) -> *JSScript;

pub fn JS_GetGlobalFromScript(script: *JSScript) -> *JSObject;

pub fn JS_CompileFunction(cx: *JSContext, obj: *JSObject, name: *c_char, nargs: c_uint, argnames: **c_char, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint) -> *JSFunction;

pub fn JS_CompileFunctionForPrincipals(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, name: *c_char, nargs: c_uint, argnames: **c_char, bytes: *c_char, length: size_t, filename: *c_char, lineno: c_uint) -> *JSFunction;

pub fn JS_CompileUCFunction(cx: *JSContext, obj: *JSObject, name: *c_char, nargs: c_uint, argnames: **c_char, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint) -> *JSFunction;

pub fn JS_CompileUCFunctionForPrincipals(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, name: *c_char, nargs: c_uint, argnames: **c_char, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint) -> *JSFunction;

pub fn JS_CompileUCFunctionForPrincipalsVersion(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, name: *c_char, nargs: c_uint, argnames: **c_char, chars: *jschar, length: size_t, filename: *c_char, lineno: c_uint, version: JSVersion) -> *JSFunction;

pub fn JS_DecompileScript(cx: *JSContext, script: *JSScript, name: *c_char, indent: c_uint) -> *JSString;

pub fn JS_DecompileFunction(cx: *JSContext, fun: *JSFunction, indent: c_uint) -> *JSString;

pub fn JS_DecompileFunctionBody(cx: *JSContext, fun: *JSFunction, indent: c_uint) -> *JSString;

pub fn JS_ExecuteScript(cx: *JSContext, obj: *JSObject, script: *JSScript, rval: *JSVal) -> JSBool;

pub fn JS_ExecuteScriptVersion(cx: *JSContext, obj: *JSObject, script: *JSScript, rval: *JSVal, version: JSVersion) -> JSBool;

pub fn JS_EvaluateScript(cx: *JSContext, obj: *JSObject, bytes: *c_char, length: c_uint, filename: *c_char, lineno: c_uint, rval: *JSVal) -> JSBool;

pub fn JS_EvaluateScriptForPrincipals(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, bytes: *c_char, length: c_uint, filename: *c_char, lineno: c_uint, rval: *JSVal) -> JSBool;

pub fn JS_EvaluateScriptForPrincipalsVersion(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, bytes: *c_char, length: c_uint, filename: *c_char, lineno: c_uint, rval: *JSVal, version: JSVersion) -> JSBool;

pub fn JS_EvaluateUCScript(cx: *JSContext, obj: *JSObject, chars: *jschar, length: c_uint, filename: *c_char, lineno: c_uint, rval: *JSVal) -> JSBool;

pub fn JS_EvaluateUCScriptForPrincipals(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, chars: *jschar, length: c_uint, filename: *c_char, lineno: c_uint, rval: *JSVal) -> JSBool;

pub fn JS_EvaluateUCScriptForPrincipalsVersion(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, chars: *jschar, length: c_uint, filename: *c_char, lineno: c_uint, rval: *JSVal, version: JSVersion) -> JSBool;

pub fn JS_EvaluateUCScriptForPrincipalsVersionOrigin(cx: *JSContext, obj: *JSObject, principals: *JSPrincipals, originPrincipals: *JSPrincipals, chars: *jschar, length: c_uint, filename: *c_char, lineno: c_uint, rval: *JSVal, version: JSVersion) -> JSBool;

pub fn JS_CallFunction(cx: *JSContext, obj: *JSObject, fun: *JSFunction, argc: c_uint, argv: *JSVal, rval: *JSVal) -> JSBool;

pub fn JS_CallFunctionName(cx: *JSContext, obj: *JSObject, name: *c_char, argc: c_uint, argv: *JSVal, rval: *JSVal) -> JSBool;

pub fn JS_CallFunctionValue(cx: *JSContext, obj: *JSObject, fval: JSVal, argc: c_uint, argv: *JSVal, rval: *JSVal) -> JSBool;

pub fn JS_SetOperationCallback(cx: *JSContext, callback: JSOperationCallback) -> JSOperationCallback;

pub fn JS_GetOperationCallback(cx: *JSContext) -> JSOperationCallback;

pub fn JS_TriggerOperationCallback(rt: *JSRuntime);

pub fn JS_IsRunning(cx: *JSContext) -> JSBool;

pub fn JS_SaveFrameChain(cx: *JSContext) -> JSBool;

pub fn JS_RestoreFrameChain(cx: *JSContext);

pub fn JS_NewStringCopyN(cx: *JSContext, s: *c_char, n: size_t) -> *JSString;

pub fn JS_NewStringCopyZ(cx: *JSContext, s: *c_char) -> *JSString;

pub fn JS_InternJSString(cx: *JSContext, str: *JSString) -> *JSString;

pub fn JS_InternStringN(cx: *JSContext, s: *c_char, length: size_t) -> *JSString;

pub fn JS_InternString(cx: *JSContext, s: *c_char) -> *JSString;

pub fn JS_NewUCString(cx: *JSContext, chars: *jschar, length: size_t) -> *JSString;

pub fn JS_NewUCStringCopyN(cx: *JSContext, s: *jschar, n: size_t) -> *JSString;

pub fn JS_NewUCStringCopyZ(cx: *JSContext, s: *jschar) -> *JSString;

pub fn JS_InternUCStringN(cx: *JSContext, s: *jschar, length: size_t) -> *JSString;

pub fn JS_InternUCString(cx: *JSContext, s: *jschar) -> *JSString;

pub fn JS_CompareStrings(cx: *JSContext, str1: *JSString, str2: *JSString, result: *int32_t) -> JSBool;

pub fn JS_StringEqualsAscii(cx: *JSContext, str: *JSString, asciiBytes: *c_char, _match: *JSBool) -> JSBool;

pub fn JS_PutEscapedString(cx: *JSContext, buffer: *c_char, size: size_t, str: *JSString, quote: c_char) -> size_t;

pub fn JS_FileEscapedString(fp: *FILE, str: *JSString, quote: c_char) -> JSBool;

pub fn JS_GetStringLength(str: *JSString) -> size_t;

pub fn JS_GetStringCharsAndLength(cx: *JSContext, str: *JSString, length: *size_t) -> *jschar;

pub fn JS_GetInternedStringChars(str: *JSString) -> *jschar;

pub fn JS_GetInternedStringCharsAndLength(str: *JSString, length: *size_t) -> *jschar;

pub fn JS_GetStringCharsZ(cx: *JSContext, str: *JSString) -> *jschar;

pub fn JS_GetStringCharsZAndLength(cx: *JSContext, str: *JSString, length: *size_t) -> *jschar;

pub fn JS_FlattenString(cx: *JSContext, str: *JSString) -> *JSFlatString;

pub fn JS_GetFlatStringChars(str: *JSFlatString) -> *jschar;

pub fn JS_FlatStringEqualsAscii(str: *JSFlatString, asciiBytes: *c_char) -> JSBool;

pub fn JS_PutEscapedFlatString(buffer: *c_char, size: size_t, str: *JSFlatString, quote: c_char) -> size_t;

pub fn JS_NewGrowableString(cx: *JSContext, chars: *jschar, length: size_t) -> *JSString;

pub fn JS_NewDependentString(cx: *JSContext, str: *JSString, start: size_t, length: size_t) -> *JSString;

pub fn JS_ConcatStrings(cx: *JSContext, left: *JSString, right: *JSString) -> *JSString;

pub fn JS_UndependString(cx: *JSContext, str: *JSString) -> *jschar;

pub fn JS_MakeStringImmutable(cx: *JSContext, str: *JSString) -> JSBool;

pub fn JS_CStringsAreUTF8() -> JSBool;

pub fn JS_SetCStringsAreUTF8();

pub fn JS_EncodeCharacters(cx: *JSContext, src: *jschar, srclen: size_t, dst: *c_char, dstlenp: *size_t) -> JSBool;

pub fn JS_DecodeBytes(cx: *JSContext, src: *c_char, srclen: size_t, dst: *jschar, dstlenp: *size_t) -> JSBool;

pub fn JS_DecodeUTF8(cx: *JSContext, src: *c_char, srclen: size_t, dst: *jschar, dstlenp: *size_t) -> JSBool;

pub fn JS_EncodeString(cx: *JSContext, str: *JSString) -> *c_char;

pub fn JS_GetStringEncodingLength(cx: *JSContext, str: *JSString) -> size_t;

pub fn JS_EncodeStringToBuffer(str: *JSString, buffer: *c_char, length: size_t) -> size_t;

pub fn JS_Stringify(cx: *JSContext, vp: *JSVal, replacer: *JSObject, space: JSVal, callback: JSONWriteCallback, data: *c_void) -> JSBool;

pub fn JS_ParseJSON(cx: *JSContext, chars: *jschar, len: uint32_t, vp: *JSVal) -> JSBool;

pub fn JS_ParseJSONWithReviver(cx: *JSContext, chars: *jschar, len: uint32_t, reviver: JSVal, vp: *JSVal) -> JSBool;

pub fn JS_ReadStructuredClone(cx: *JSContext, data: *uint64_t, nbytes: size_t, version: uint32_t, vp: *JSVal, optionalCallbacks: *JSStructuredCloneCallbacks, closure: *c_void) -> JSBool;

pub fn JS_WriteStructuredClone(cx: *JSContext, v: JSVal, datap: **uint64_t, nbytesp: *size_t, optionalCallbacks: *JSStructuredCloneCallbacks, closure: *c_void) -> JSBool;

pub fn JS_StructuredClone(cx: *JSContext, v: JSVal, vp: *JSVal, optionalCallbacks: *JSStructuredCloneCallbacks, closure: *c_void) -> JSBool;

pub fn JS_SetStructuredCloneCallbacks(rt: *JSRuntime, callbacks: *JSStructuredCloneCallbacks);

pub fn JS_ReadUint32Pair(r: *JSStructuredCloneReader, p1: *uint32_t, p2: *uint32_t) -> JSBool;

pub fn JS_ReadBytes(r: *JSStructuredCloneReader, p: *c_void, len: size_t) -> JSBool;

pub fn JS_ReadTypedArray(r: *JSStructuredCloneReader, vp: *JSVal) -> JSBool;

pub fn JS_WriteUint32Pair(w: *JSStructuredCloneWriter, tag: uint32_t, data: uint32_t) -> JSBool;

pub fn JS_WriteBytes(w: *JSStructuredCloneWriter, p: *c_void, len: size_t) -> JSBool;

pub fn JS_WriteTypedArray(w: *JSStructuredCloneWriter, v: JSVal) -> JSBool;

pub fn JS_SetLocaleCallbacks(cx: *JSContext, callbacks: *JSLocaleCallbacks);

pub fn JS_GetLocaleCallbacks(cx: *JSContext) -> *JSLocaleCallbacks;

pub fn JS_ReportError(cx: *JSContext, format: *c_char/* FIXME: variadic function */);

pub fn JS_ReportErrorNumber(cx: *JSContext, errorCallback: JSErrorCallback, userRef: *c_void, errorNumber: c_uint/* FIXME: variadic function */);

pub fn JS_ReportErrorNumberUC(cx: *JSContext, errorCallback: JSErrorCallback, userRef: *c_void, errorNumber: c_uint/* FIXME: variadic function */);

pub fn JS_ReportWarning(cx: *JSContext, format: *c_char/* FIXME: variadic function */) -> JSBool;

pub fn JS_ReportErrorFlagsAndNumber(cx: *JSContext, flags: c_uint, errorCallback: JSErrorCallback, userRef: *c_void, errorNumber: c_uint/* FIXME: variadic function */) -> JSBool;

pub fn JS_ReportErrorFlagsAndNumberUC(cx: *JSContext, flags: c_uint, errorCallback: JSErrorCallback, userRef: *c_void, errorNumber: c_uint/* FIXME: variadic function */) -> JSBool;

pub fn JS_ReportOutOfMemory(cx: *JSContext);

pub fn JS_ReportAllocationOverflow(cx: *JSContext);

pub fn JS_GetErrorReporter(cx: *JSContext) -> JSErrorReporter;

pub fn JS_SetErrorReporter(cx: *JSContext, er: JSErrorReporter) -> JSErrorReporter;

pub fn JS_NewDateObject(cx: *JSContext, year: c_int, mon: c_int, mday: c_int, hour: c_int, min: c_int, sec: c_int) -> *JSObject;

pub fn JS_NewDateObjectMsec(cx: *JSContext, msec: c_double) -> *JSObject;

pub fn JS_ObjectIsDate(cx: *JSContext, obj: JSRawObject) -> JSBool;

pub fn JS_ClearDateCaches(cx: *JSContext);

pub fn JS_NewRegExpObject(cx: *JSContext, obj: *JSObject, bytes: *c_char, length: size_t, flags: c_uint) -> *JSObject;

pub fn JS_NewUCRegExpObject(cx: *JSContext, obj: *JSObject, chars: *jschar, length: size_t, flags: c_uint) -> *JSObject;

pub fn JS_SetRegExpInput(cx: *JSContext, obj: *JSObject, input: *JSString, multiline: JSBool);

pub fn JS_ClearRegExpStatics(cx: *JSContext, obj: *JSObject);

pub fn JS_ExecuteRegExp(cx: *JSContext, obj: *JSObject, reobj: *JSObject, chars: *jschar, length: size_t, indexp: *size_t, test: JSBool, rval: *JSVal) -> JSBool;

pub fn JS_NewRegExpObjectNoStatics(cx: *JSContext, bytes: *c_char, length: size_t, flags: c_uint) -> *JSObject;

pub fn JS_NewUCRegExpObjectNoStatics(cx: *JSContext, chars: *jschar, length: size_t, flags: c_uint) -> *JSObject;

pub fn JS_ExecuteRegExpNoStatics(cx: *JSContext, reobj: *JSObject, chars: *jschar, length: size_t, indexp: *size_t, test: JSBool, rval: *JSVal) -> JSBool;

pub fn JS_ObjectIsRegExp(cx: *JSContext, obj: *JSObject) -> JSBool;

pub fn JS_GetRegExpFlags(cx: *JSContext, obj: *JSObject) -> c_uint;

pub fn JS_GetRegExpSource(cx: *JSContext, obj: *JSObject) -> *JSString;

pub fn JS_IsExceptionPending(cx: *JSContext) -> JSBool;

pub fn JS_GetPendingException(cx: *JSContext, vp: *JSVal) -> JSBool;

pub fn JS_SetPendingException(cx: *JSContext, v: JSVal);

pub fn JS_ClearPendingException(cx: *JSContext);

pub fn JS_ReportPendingException(cx: *JSContext) -> JSBool;

pub fn JS_SaveExceptionState(cx: *JSContext) -> *JSExceptionState;

pub fn JS_RestoreExceptionState(cx: *JSContext, state: *JSExceptionState);

pub fn JS_DropExceptionState(cx: *JSContext, state: *JSExceptionState);

pub fn JS_ErrorFromException(cx: *JSContext, v: JSVal) -> *JSErrorReport;

pub fn JS_ThrowReportedError(cx: *JSContext, message: *c_char, reportp: *JSErrorReport) -> JSBool;

pub fn JS_ThrowStopIteration(cx: *JSContext) -> JSBool;

pub fn JS_GetCurrentThread(/* FIXME: variadic function */) -> intptr_t;

pub fn JS_AbortIfWrongThread(rt: *JSRuntime);

pub fn JS_ClearRuntimeThread(rt: *JSRuntime);

pub fn JS_SetRuntimeThread(rt: *JSRuntime);

pub fn JS_SetNativeStackBounds(rt: *JSRuntime, stackBase: uintptr_t, stackEnd: uintptr_t);

pub fn JS_NewObjectForConstructor(cx: *JSContext, clasp: *JSClass, vp: *JSVal) -> *JSObject;

pub fn JS_IndexToId(cx: *JSContext, index: uint32_t, id: *jsid) -> JSBool;

pub fn JS_IsIdentifier(cx: *JSContext, str: *JSString, isIdentifier: *JSBool) -> JSBool;

pub fn JS_DescribeScriptedCaller(cx: *JSContext, script: **JSScript, lineno: *c_uint) -> JSBool;

pub fn JS_EncodeScript(cx: *JSContext, script: *JSScript, lengthp: *uint32_t) -> *c_void;

pub fn JS_EncodeInterpretedFunction(cx: *JSContext, funobj: JSRawObject, lengthp: *uint32_t) -> *c_void;

pub fn JS_DecodeScript(cx: *JSContext, data: *c_void, length: uint32_t, principals: *JSPrincipals, originPrincipals: *JSPrincipals) -> *JSScript;

pub fn JS_DecodeInterpretedFunction(cx: *JSContext, data: *c_void, length: uint32_t, principals: *JSPrincipals, originPrincipals: *JSPrincipals) -> *JSObject;

}
